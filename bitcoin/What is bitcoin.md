
### 하나의 블록에는 어떤 정보가 있는가

거래기록
하나의 거래(트랜젝션)는 해시함수를 통해서 해시값으로 변환
이전 블록의 해시값: 32바이트
머클 루트: 32바이트
해당 블록의 고유한 블록 해시값: 32바이트 (이 값은 이전 블록 해시값, 머클 루트 등 블록의 모든 내용을 해시화하여 생성됩니다) 

따라서, 이 세 가지 해시값만 고려하면 32바이트 * 3 = 96바이트가 되지만, 블록은 이 해시값들 외에 훨씬 더 많은 데이터를 포함하고 있습니다.
블록의 주요 내용은 바로 거래 내역(transaction records) 또는 거래 기록입니다. 하나의 블록에는 일정 기간 동안 발생한 여러 개의 거래 내역이 담깁니다. 예를 들어, 비트코인 네트워크에서는 약 10분 주기로 블록이 생성되며, 이 블록에는 약 10분간의 거래 기록이 포함됩니다1.
비트코인의 경우, 블록의 크기가 1개당 1MB 이내로 제한되어 있으며, 현재 모든 블록체인 거래기록의 원본을 보유한 풀 노드(Full node)의 용량은 약 200GB 정도입니다. 이처럼 블록은 수많은 트랜잭션 데이터를 포함하기 때문에 96바이트보다 훨씬 큰 용량을 가집니다.


### 공개원장
거래 내역(=데이터)을 저장하는 분산형 데이터 저장 기술
블록에 데이터를 담아 체인 형태로 연결한 후, 이를 복제해 수많은 컴퓨터(=노드)에 동시에 저장하는 분산형 데이터 저장 기술
탈중앙화 (Decentralization) : 모든 거래자들의 개별 컴퓨터(노드)에 거래 장부를 공유하고 보관하며, 이 거래자들이 자발적으로 모여 네트워크를 유지 및 관리
투명성 (Transparency): 블록체인의 모든 거래 내역은 공개 원장에 기록


### 트릴레마(Trilemma)
블록체인 트릴레마 블록체인이 확장성, 탈중앙화, 보안 세 가지 요소를 동시에 만족하는 것은 어렵다.

1. 확장성(Scalability)
사용자 수가 증가하거나 네트워크의 규모가 커지면서, 데이터 처리량 또는 데이터 전송 건수가 얼마나 증가할 수 있는가.
즉, 블록체인 네트워크가 트랜잭션을 얼마나 빠르게 처리할 수 있는가? (TPS, Transaction Per Second)(But, 'TPS = 확장성'은 아님!)
확장성을 높이려고 시도해볼 수 있지만, 탈중앙화나 보안에 악영향을 줄 수 있음 (예: 비트코인캐시)
확장성을 증가시키는 두 가지 방법 - 탈중앙화에 대한 타협: 거래를 검토하는 엔터티의 수 줄이기 - 보안에 대한 타협: 네트워크의 난이도 감소를 요구하는 블록 타임의 감소

2. 탈중앙화(Deccentralization)
네트워크가 중앙집권화된 서버로 운영되는 것이 아닌, 소규모 노드 간 자율적으로 운영되는 것.
블록체인 기술의 핵심 아이디어이며, 중개자의 역할이 사라지고 더 많은 사람들에게 이익을 분배할 수 있는 구조가 됨.
탈중앙화 네트워크는 합의(Consensus)를 통해 의사결정을 내림.

3. 보안(Security)
데이터나 프로그램이 보호되어 있고, 권한이 없는 사용자나 악의적인 사용자의 접근을 막는 것.
노드 수가 부족하고 해시율이 낮아지면 해킹 위험이 큼. 따라서 BTC, ETH과 같은 메이저 코인들은 현실적으로 해킹 위험이 낮음.

### 거래내용
사용자가 "A가 B에게 50BTC를 보냅니다"와 같은 거래 내역을 작성하고1, 실제 돈의 소유자임을 확인할 수 있는 서명을 한 후 네트워크에 전송합니다
생성된 거래는 블록체인 네트워크로 전송됩니다. 네트워크에 참여하는 노드들(개개인의 서버이자 참여자)은 해당 거래가 올바른지, 즉 거래의 유효성을 확인하고 이중 지불(double-spending) 문제가 없는지 검증합니다. 개별 트랜잭션은 해시 함수를 거쳐 일정한 길이의 해시값으로 전환되어 식별이 용이해지고 무결성을 확인할 수 있습니다.
새로운 블록을 생성하기 위해 작업 증명(Proof of Work) 또는 지분 증명(Proof of Stake)과 같은 합의 알고리즘을 사용합니다10. 블록체인 시스템에는 중앙 관리자가 없기 때문에11, 블록을 배포하는 노드의 역할이 중요하며, 참여하는 노드들 가운데 과반수 이상(51% 이상)의 동의가 있어야 새 블록이 생성됩니다

### nonce
'nonce'는 "number used once"의 줄임말로, 컴퓨터 과학 및 암호학에서 한 번만 사용되는 임의의 숫자를 의미합니다. 블록체인의 작업 증명(PoW) 과정인 **채굴(Mining)**에서 중요한 역할을 합니다.

채굴자(마이너)는 새로운 블록을 만들기 위해 복잡한 암호화 퍼즐을 풀어야 하는데1. 이 퍼즐을 풀기 위해 블록에 포함된 데이터(거래 내역, 이전 블록의 해시값 등)와 함께 Nonce 값을 변경해가며 특정 조건을 만족하는 해시값을 찾습니다. 즉, Nonce는 블록의 해시값을 변경하여 원하는 조건을 만족시키는 '정답'을 찾기 위해 무수히 대입해보는 가변적인 숫자입니다.

이렇게 조건을 만족하는 해시값을 찾은 채굴자가 새로운 블록을 네트워크에 전파하고, 다른 노드들이 이를 검증함으로써 블록이 체인에 추가됩니다. 이 과정에서 해시율(Hashrate)이 채굴 성공 확률과 연관되어 난이도를 높인다고 언급되어 있습니다2.

요약하자면, 제공된 자료 내에서는 'nonce'에 대한 설명이 없지만, 블록체인 채굴 과정에서 특정 조건을 만족하는 블록 해시를 찾기 위해 사용되는 가변적인 숫자입니다.

### 백서
Abstract
1. Introduction
(이 섹션에서는 암호화폐 시스템의 필요성과 이중 지불 문제 해결에 대한 제안을 다룹니다)

2. Transactions
(전자 코인을 디지털 서명의 체인으로 정의하고, 기존 중앙 집중식 해결책의 문제점을 설명합니다)

3. Timestamp Server
(타임스탬프 서버가 블록의 해시를 게시하여 데이터의 존재 시점을 증명하는 방법을 제시합니다)

4. Proof-of-Work
(분산형 타임스탬프 서버 구현을 위한 작업 증명 시스템을 설명하며, nonce 값을 증가시켜 블록 해시가 특정 조건을 만족하도록 찾는 과정을 포함합니다. 이는 블록이 변경될 경우 작업을 다시 해야 하므로 보안성을 강화합니다)
(작업 증명은 또한 다수결 결정에서 CPU 파워가 '1 CPU 1 투표'로 작용하며, 가장 긴 체인이 가장 많은 작업 증명 노력이 투입된 것으로 간주됩니다)
(하드웨어 속도 및 노드 참여도 변화에 맞춰 작업 증명 난이도가 시간당 평균 블록 수에 따라 조정됩니다)

5. Network
(네트워크 작동 단계를 설명합니다: 새로운 거래 방송, 노드의 블록 구성, 작업 증명 찾기, 블록 방송 및 수락, 그리고 수락된 블록의 해시를 다음 블록의 이전 해시로 사용하여 체인을 확장하는 과정)
(노드들은 항상 가장 긴 체인을 정확한 것으로 간주하며, 이의 확장에 집중합니다)

6. Incentive
(블록 생성자에게 새로운 코인을 지급하거나 거래 수수료를 통해 네트워크 지원에 대한 인센티브를 제공합니다. 이는 시스템의 정직한 운영을 장려합니다)

7. Reclaiming Disk Space
(디스크 공간 절약을 위해 오래된 거래를 폐기하는 방법과, 블록 해시를 깨지 않고 이를 가능하게 하는 머클 트리(Merkle Tree) 사용법을 설명합니다. 블록 헤더는 작고, 저장 공간은 문제가 되지 않을 것으로 예상합니다)

8. Simplified Payment Verification
(전체 네트워크 노드를 실행하지 않고도 결제를 검증하는 간소화된 방법을 설명합니다. 이는 가장 긴 작업 증명 체인의 블록 헤더와 거래가 포함된 블록의 머클 브랜치를 확인하는 방식입니다)

9. Combining and Splitting Value
(가치를 분할하고 결합하기 위해 거래에 여러 입력과 출력을 포함시키는 방법을 설명합니다)

10. Privacy
(모든 거래가 공개적으로 발표되지만, 공개 키를 익명으로 유지하여 개인 정보를 보호하는 방법을 설명합니다)

11. Calculations
(공격자가 정직한 체인보다 빠르게 대체 체인을 생성하려는 시나리오에 대한 계산 모델을 제시합니다. 공격자가 따라잡을 확률이 블록 수가 증가함에 따라 기하급수적으로 감소함을 보여줍니다)

12. Conclusion
(신뢰할 수 있는 제삼자 없이 전자 거래를 가능하게 하는 시스템을 제안하며, 이중 지불 문제 해결, 작업 증명을 통한 공개 거래 기록 보존, 그리고 네트워크의 견고성을 강조합니다)


### 작업증명
'작업 증명(Proof-of-Work, PoW)'은 블록체인 시스템, 특히 비트코인과 같은 암호화폐에서 새로운 블록을 생성하고 거래의 유효성을 검증하며 네트워크의 보안을 유지하는 핵심적인 합의 알고리즘입니다
작업 증명은 순전히 피어-투-피어(peer-to-peer) 방식의 전자 화폐 시스템에서 이중 지불(double-spending) 문제를 해결하기 위해 제안된 방식입니다
이는 분산형 타임스탬프 서버를 구현하기 위해 활용됩니다. 블록의 해시를 지속적인 작업 증명 체인에 해싱하여, 변경하려면 작업 증명을 다시 해야 하는 기록을 형성합니다
이 조건을 만족하는 해시값을 찾기 위해 블록에 포함된 데이터(거래 내역, 이전 블록의 해시값 등)와 함께 'nonce' 값을 계속해서 증가시킵니다. 이전 대화에서 설명드렸듯이, nonce는 "number used once"의 줄임말로, 블록의 해시값을 변경하여 원하는 조건을 만족시키는 '정답'을 찾기 위해 무수히 대입해보는 가변적인 숫자입니다.

### 암호화 알고리즘
1. SHA-256 / 공개키생성

- 해시 함수
- 블록 해시 계산, 채굴(Proof of Work), 공개키 해시 등에서 사용
- 256비트 해시값 생성

1. RIPEMD-160 /주소생성

- 해시 함수
- 비트코인 주소 생성 시, 공개키를 SHA-256로 해시한 후 다시 RIPEMD-160으로 해시
- 160비트 해시값 생성

1. Base58Check 인코딩 /주소인코딩

- 인코딩 및 체크섬
- 비트코인 주소를 사람이 읽기 쉬운 형태로 변환, 입력 실수 방지용 체크섬 포함

1. ECDSA (secp256k1) / 디지털 서명

- 공개키 암호 및 디지털 서명
- 트랜잭션 서명, 개인키로 공개키 생성
- 타원곡선 암호(ECC) 기반

1. HMAC-SHA512 

- 해시 기반 메시지 인증 코드
- HD 지갑에서 시드와 자식 키 생성에 사용

6. SHA-1

- 해시 함수
- BIP39 니모닉 코드 등 일부 파생 표준에서 한정적 사용

### 가장 긴 체인이란?

### 디지털 서명
| 구분      | 해시값인가? | 설명                            |
| ------- | ------ | ----------------------------- |
| 공개키     | ✗      | 개인키로부터 수학적으로 계산된 값(암호학적 키)    |
| 개인키     | ✗      | 임의의 큰 숫자(비밀, 암호학적 키)          |
| 해시      | O      | 데이터를 고정된 길이로 변환한 값(SHA-256 등) |
| 비트코인 주소 | O      | 공개키에 해시 함수를 적용해서 만듦           |
**개인키(Private Key)** : 비밀로 간직하는, 임의의 매우 큰 16진수 숫자
1E99423A4ED27608A15A2616CE6DFD1F7B9F0A1B5B6F8B6D2C8A9D6C7B6A9C3A

**공개키(Public Key)** : 개인키로부터 수학적으로 계산된 값, 16진수로 표현된 매우 긴 문자열
04FC9702847840AFCB68421B0CE0E5B1A6C8D0F4B1A1B5A6A7D1C1E2F3B4C5D6E7F8A9B0C1D2E3F4A5B6C7D8E9F0A1B2C3D4E5F6A7B8C9D0E1F2

**공개키 해시(Public Key Hash)**
62E907B15CBF27D5425399EBF6F0FB50EBB88F18(20바이트, 40자리 16진수)

**비트코인 주소(Bitcoin Address)** : 공개키 해시에 추가적인 변환(Base58Check 인코딩 등) 후 사용자에게 보여지는 형태
1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa

역추적이 불가능: 타원곡선 이산로그 문제(ECDLP)라는 매우 어려운 수학 문제에 기반

1. **트랜잭션 생성:**  
    비트코인을 보내려는 사람이 **트랜잭션(거래 정보)**를 만듭니다.
    
2. **개인키로 서명:**  
    이 트랜잭션에 **개인키로 디지털 서명**을 합니다.
    
    - 이때 개인키는 외부에 절대 노출되지 않습니다.
    - 
3. **트랜잭션 전송:**  
    서명된 트랜잭션을 네트워크에 보냅니다.
    
4. **네트워크의 검증:**
    
    - 네트워크(채굴자/노드)는 **공개키**를 사용해서  
        이 서명이 진짜인지, 즉 올바른 소유자가 맞는지 확인합니다
        
서명은 특정 데이터(예: 트랜잭션 정보)와 개인키를 이용해  
특별한 수학적 계산을 해서 만들어진 서명 값(signature)입니다.
이 서명 값은 거래 정보와 공개키로만 검증할 수 있고,  
여기서 개인키가 무엇인지 역추적할 수 없습니다.

### 트랜젝션

- `txid`: 트랜잭션의 고유 식별자(해시)
- `vin`: 입력. 이전 트랜잭션의 출력(UTXO)을 참조. 소유 증명(서명, 공개키) 포함
- `vout`: 출력. 누구에게 얼마를 보내는지(주소, 금액, 잠금 스크립트)
- `scriptSig`: 입력 해제 조건(서명, 공개키)
- `scriptPubKey`: 출력 잠금 조건(비트코인 주소와 연결)
- `value`: 해당 출력에 할당된 비트코인 수

예시
{
  "txid": "e2a8c6...",
  "version": 1,
  "vin": [
    {
      "txid": "7b1eabe...",
      "vout": 0,
      "scriptSig": {
        "asm": "3045... [서명] 02b4... [공개키]",
        "hex": "4830..."
      },
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.015,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 ab680d... OP_EQUALVERIFY OP_CHECKSIG",
        "hex": "76a914...",
        "type": "pubkeyhash",
        "addresses": [
          "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"
        ]
      }
    },
    {
      "value": 0.0845,
      "n": 1,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 1b2a8d... OP_EQUALVERIFY OP_CHECKSIG",
        "hex": "76a914...",
        "type": "pubkeyhash",
        "addresses": [
          "1BoatSLRHtKNngkdXEeobR76b53LETtpyT"
        ]
      }
    }
  ],
  "locktime": 0
}

1. txid (Transaction ID) 트랜잭션의 고유 식별자입니다.  
    트랜잭션 전체 데이터를 두 번 SHA-256 해싱하여 만듭니다.  
    트랜잭션을 추적하거나 참조할 때 사용되며, UTXO(미사용 출력)를 참조할 때 입력에서 사용됩니다.  
    블록체인에 기록된 뒤에도 변하지 않습니다.
    
2. vin (입력, Input) 이 트랜잭션이 사용하는 비트코인의 출처 목록입니다.  
    이전 트랜잭션의 출력(UTXO)을 참조합니다.  
    각 입력에는 다음 정보가 포함됩니다:
    

- txid: 참조하는 이전 트랜잭션의 ID
- vout: 참조하는 출력의 인덱스
- scriptSig: 해당 UTXO를 사용할 수 있음을 증명하는 스크립트(보통 서명과 공개키)
- sequence: 특별한 기능에서 사용, 보통 고정값  
    입력은 "이 비트코인은 내가 소유한 것이다"를 증명하고, 이전 소유자로부터 비트코인을 받아오는 역할을 합니다.

3. vout (출력, Output) 이 트랜잭션이 새롭게 만드는 비트코인 소유권의 목록입니다.  
    누구에게 얼마를 보낼지 나타냅니다.  
    각 출력에는 다음 정보가 포함됩니다:

- value: 해당 출력에 할당되는 비트코인 수량
- scriptPubKey: 이 비트코인을 사용할 수 있는 조건(보통은 특정 주소의 공개키 해시)
- n: 출력 인덱스  
    출력은 "이 주소에 얼마를 보낸다"를 명시하며, 이후 이 출력이 다른 트랜잭션의 입력으로 사용됩니다.

4. scriptSig (입력 해제 조건) 입력(UTXO)을 사용할 수 있음을 증명하는 작은 프로그램(스크립트)입니다.  
    보통 서명과 공개키가 들어갑니다.  
    UTXO를 잠근 scriptPubKey와 scriptSig가 합쳐져 실행되며, 올바른 공개키와 서명을 제공해야 해당 UTXO를 사용할 수 있습니다.  
    "이 비트코인을 쓸 권리가 있다"를 증명하는 부분입니다.
    
5. scriptPubKey (출력 잠금 조건) 이 출력(비트코인)을 어떻게 해야 사용할 수 있는지 정의하는 스크립트입니다.  
    보통 특정 공개키 해시가 들어갑니다.  
    "이 공개키 해시에 맞는 공개키와 올바른 서명을 제공해야만 이 비트코인을 쓸 수 있다"는 조건을 명시합니다.  
    다양한 형태의 스크립트(멀티시그, 시간잠금 등)도 가능합니다.  
    "이 조건을 만족해야만 이 비트코인을 쓸 수 있다"를 의미합니다.
    
6. value (값) 해당 출력에 할당된 비트코인 수량입니다.  
    BTC 단위로 표시되지만, 실제 데이터상에서는 1BTC가 1억 사토시로 저장됩니다.  
    해당 출력이 가진 비트코인 양을 나타내며, 입력의 총합은 출력의 총합과 수수료의 합보다 크거나 같아야 합니다.
    

트랜잭션은 입력을 통해 기존의 소유권(UTXO)을 해제하고, 출력을 통해 새로운 소유권을 생성합니다.  
scriptSig와 scriptPubKey는 합쳐서 실행되어 올바른 소유자만 비트코인을 사용할 수 있도록 보장합니다.  
value는 실제로 이동하는 비트코인 양을 나타냅니다.


### 네트워크 통신
- **노드(Node)**  
    비트코인 소프트웨어(Bitcoin Core 등)를 실행하는 컴퓨터입니다.  
    블록체인 데이터를 저장하고, 새로운 트랜잭션/블록을 검증·전파합니다.
- **프로토콜**  
    비트코인은 자체적으로 정의한 네트워크 프로토콜을 사용합니다.  
    TCP/IP 기반(기본 포트: 8333)으로 동작합니다.
- 주요 메시지 타입:

- `version`: 연결 시 자신의 프로토콜 버전, 블록체인 상태 등 전송
- `verack`: 버전 확인 응답
- `inv`: 새로운 트랜잭션/블록이 있음을 알림(Inventory)
- `getdata`: 필요한 실제 데이터를 요청
- `tx`: 트랜잭션 데이터 전달
- `block`: 블록 데이터 전달
- `addr`: 다른 노드의 주소 정보 전달

`// 메시지 수신 및 처리 함수 (pseudo code) void ProcessMessages(CNode* pfrom) 
{
while (!pfrom->vRecv.empty()) {         
CNetMessage msg = pfrom->vRecv.front();         
// 메시지 타입에 따라 분기        
if (msg.command == "inv") {             
// 새로운 데이터 알림 처리         
} 
else if (msg.command == "getdata") {            
// 데이터 요청 처리         
} 
else if (msg.command == "tx") {             
// 트랜잭션 데이터 처리         
}         
// ...         
pfrom->vRecv.pop_front();    
	} 
}

### 비트코인은 어떤 형식으로 존재하는가
UTXO(미사용 트랜잭션 출력, Unspent Transaction Output)
아직 누군가가 사용하지 않은 비트코인 조각
- 모든 비트코인은 과거 트랜잭션의 결과로 생성된 UTXO의 집합으로 존재합니다.
- 새로운 트랜잭션을 만들 때는, 본인이 소유한 UTXO를 입력으로 사용해서
	새로운 UTXO(아직 사용되지 않은 트랜잭션 출력)를 만듭니다.
	
	1. **블록의 각 트랜잭션을 처리**
    
    - 새로운 트랜잭션의 각 출력(Output)을 UTXO 세트에 추가
    - 트랜잭션의 입력(Input)으로 사용된 UTXO는 UTXO 세트에서 제거
2. **최종적으로 남아 있는 UTXO 세트**
    
    - 이 세트에 포함된 모든 UTXO의 금액을 합산하면  
        => "전체 네트워크의 사용 가능한 비트코인 총량"이 됨

### 채굴
채굴의 목적
- **새로운 트랜잭션을 묶어 블록을 만들고 블록체인에 추가**
- **네트워크 보안 유지** (이중지불 방지, 트랜잭션 검증)
- **새로운 비트코인 발행** (채굴자 보상)
트랜잭션 모으기

- 네트워크에서 전송된 **미확인 트랜잭션**(mempool에 있음)을 모음

블록 생성

- 모은 트랜잭션을 하나의 “블록”에 담음
- 맨 첫 번째 트랜잭션은 **코인베이스 트랜잭션**(coinbase transaction)  
    → 채굴자의 보상(새로운 비트코인 + 수수료)을 받는 특별한 트랜잭션

해시 퍼즐 풀기 (Proof of Work)

- 블록 헤더에 임의의 숫자(nonce)를 바꿔가며  
    **특정 조건(난이도)**을 만족하는 해시값이 나올 때까지 반복
- 이 조건은 "해시값이 특정 개수의 0으로 시작해야 한다" 등 매우 어렵게 설정됨

성공 시 블록 전파

- 조건을 만족하면 **블록을 네트워크에 전파**
- 다른 노드들이 블록의 유효성을 검증

블록체인에 추가

- 블록이 승인되면,  
    채굴자는 **코인베이스 트랜잭션의 UTXO**를 통해  
    새로운 비트코인을 소유하게 됨
- **예측 불가능성**과 **보안**을 위해  
    블록 생성 시간을 완전히 고정할 수는 없습니다.
- 대신, **난이도 조정**을 통해  
    전체적으로 10분에 한 번꼴로 맞추는 것이죠.

### 미확인 트랜잭션, unconfirmed transactions) 대응

- 누군가 비트코인 전송을 요청하면,  
    그 트랜잭션은 **먼저 “메모리풀(Mempool)”**이라는 대기열에 들어갑니다.
- 아직 블록에 포함되어 **채굴자에 의해 검증**되지 않은 상태입니다.
- 이걸 **미확인 트랜잭션** 또는 **대기 중 트랜잭션**이라고 부릅니다.
- - **트랜잭션 수가 급증**하거나
- **블록 크기(1MB) 제한** 때문에  
    한 번에 블록에 포함될 수 없는 트랜잭션이 많아질 경우  
    → **Mempool에 대기 중인 트랜잭션**이 점점 늘어남
    수수료 경쟁**이 심해짐
    처리 지연
    Mempool이 꽉 차면 자동으로 삭제될 수 있음

- **수수료 시장(Fee Market)**이 자연스럽게 형성됨  
    → 네트워크가 혼잡할수록 수수료가 오름
- 사용자는 **“얼마나 빨리 처리되길 원하는지”**에 따라  
    수수료를 직접 조정할 수 있음
- **블록 크기 제한**을 늘리거나,  
    **라이트닝 네트워크** 같은 2차 확장 솔루션이 도입됨  
    (빠르고 저렴한 소액 결제를 지원)

### 확장솔루션
1. 왜 확장 솔루션이 필요한가?

비트코인은 블록 크기가 1MB로 제한되어 있고, 블록이 10분마다 생성되기 때문에 초당 약 7건 정도의 거래밖에 처리하지 못합니다. 사용자가 많아지면 거래가 밀리고, 수수료가 오르는 현상이 발생합니다. 더 많은 거래를 빠르게, 그리고 저렴하게 처리하려면 확장 솔루션이 꼭 필요합니다.

2. 확장 솔루션의 종류

첫 번째로 온체인 확장 방법이 있습니다. 온체인 확장이란, 블록체인 자체의 구조를 바꿔 처리량을 늘리는 방법입니다.

블록 크기를 늘리는 방법이 대표적입니다. 예를 들어 비트코인 캐시(BCH)는 블록 크기를 32MB로 늘려 한 번에 더 많은 거래를 처리할 수 있습니다. 이 방법은 구현이 간단하지만, 블록이 커질수록 전체 네트워크를 운영하는 데 필요한 컴퓨터 성능과 저장 공간이 늘어나 중앙화 위험이 커질 수 있습니다.
[[온체인용량증가시문제점]]
세그윗(SegWit, Segregated Witness)이라는 기술도 있습니다. 이 방법은 거래의 서명 데이터를 분리해서 블록당 더 많은 거래를 담을 수 있게 해줍니다. 2017년 비트코인에 도입되었으며, 트랜잭션 처리량이 증가하고 보안성도 높아집니다. 다만, 근본적으로 처리량이 크게 늘어나는 것은 아닙니다.

두 번째로 오프체인 확장 방법이 있습니다. 오프체인 확장은 블록체인 바깥에서 거래를 처리하는 방식입니다.

라이트닝 네트워크가 대표적인 예입니다. 라이트닝 네트워크에서는 사용자끼리 별도의 지불 채널을 열고, 그 안에서 자유롭게 빠르고 저렴하게 거래할 수 있습니다. 이 채널에서 이뤄진 거래 내역은 나중에 최종 결과만 블록체인에 기록합니다. 거의 즉시 결제가 가능하고 수수료도 매우 저렴합니다. 다만, 채널을 열거나 닫을 때는 블록체인 거래가 필요하고, 사용법이 아직은 조금 복잡할 수 있습니다.

사이드체인이라는 방식도 있습니다. 사이드체인은 메인 블록체인과 별도로 운영되는 또 다른 블록체인에서 자산을 옮겨 다양한 기능이나 빠른 거래를 지원합니다. 예를 들어 Liquid Network나 RSK가 있습니다. 다양한 기능을 실험할 수 있고, 확장성이 높지만 별도의 보안과 신뢰 문제가 추가로 생길 수 있습니다.

3. 요약

온체인 확장은 블록체인 자체를 개선하는 방식이고, 오프체인 확장은 블록체인 바깥에서 거래를 처리한 뒤 결과만 기록하는 방식입니다. 온체인 확장에는 블록 크기 증가, 세그윗 등이 있고, 오프체인 확장에는 라이트닝 네트워크, 사이드체인 등이 있습니다. 각각 장단점이 있으니 상황에 따라 조합해서 사용합니다.

4. 비유로 쉽게 설명하면, 온체인 확장은 고속도로 차선을 늘려서 더 많은 차가 지나가게 하는 것이고, 오프체인 확장은 고속도로 옆에 지하철을 만들어 일부 승객이 빠르게 이동하도록 하는 것과 비슷합니다.

결론적으로, 확장 솔루션은 비트코인 네트워크가 더 많은 사용자를 수용하고, 더 빠르고 저렴하게 거래할 수 있게 해주는 다양한 기술을 뜻합니다. 비트코인은 온체인과 오프체인 확장 방법을 모두 활용해 점진적으로 처리량을 높여가고 있습니다.
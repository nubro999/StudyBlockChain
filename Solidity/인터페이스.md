
## 1. **인터페이스란?**

- 인터페이스는 **함수의 시그니처(이름, 입력, 출력)**만 정의하고  
    **구현(내용)**은 없는 일종의 "약속"입니다.
- 실제로 함수가 어떻게 동작하는지는 알 필요 없이,  
    **함수 호출 방법만 명확히 알려줍니다.**

---

## 2. **왜 인터페이스를 쓰는가?**

### 1) **다른 컨트랙트와 상호작용하기 위해**

- 이더리움에서는 **다른 컨트랙트의 함수**를 직접 호출할 수 있습니다.
- 하지만, **Solidity 컴파일러는 함수의 정의(시그니처)**를 알아야 호출이 가능합니다.
- 전체 코드를 알 필요 없이, **인터페이스만 알면 함수 호출이 가능**합니다.

### 2) **코드를 더 깔끔하고 안전하게 만들기 위해**

- 함수 호출 시, 잘못된 타입이나 잘못된 함수명을 방지할 수 있습니다.
- ABI(함수의 입출력 정보)를 자동으로 맞춰줍니다.

---

## 3. **실제 코드 분석**

복사

```sol
`interface IChallenge {     function giveMeFlag(uint ans1, bytes calldata ans2) external returns (bool); }`
```

- `IChallenge`는 **문제 컨트랙트(Challenge)의 함수 시그니처**만 정의
- 실제 구현(함수 내용)은 없음



```python
`contract ProxyCaller {     function callGiveMeFlag(         address challengeAddr,         uint ans1,         bytes calldata ans2     ) external {         IChallenge(challengeAddr).giveMeFlag(ans1, ans2);     } }`
```


- `ProxyCaller` 컨트랙트는 `IChallenge` 인터페이스를 사용해,
- **임의의 주소(challengeAddr)에 있는 컨트랙트의 giveMeFlag 함수를 호출**함
- 이때, challengeAddr에 실제 Challenge 컨트랙트가 배포되어 있어야 함

---

## 4. **정리**

|인터페이스 사용 이유|설명|
|---|---|
|함수 시그니처만 알면 호출 가능|구현 내용 없이, 함수명/입출력만 알면 됨|
|다른 컨트랙트와 안전하게 호출|타입 체크, 함수 존재 여부 등을 컴파일러가 확인|
|코드를 더 명확하게 분리|실제 컨트랙트 코드 없이도 함수 호출 가능|

---

## 5. **비유**

- **인터페이스**는 "전화번호부"와 비슷합니다.
    - 전화번호부에 "김철수: 010-1234-5678"만 있으면
    - 김철수가 누구인지, 뭘 하는 사람인지는 몰라도
    - **전화는 걸 수 있습니다!**
- 마찬가지로,
    - 인터페이스에 함수 시그니처만 있으면
    - 실제 구현이 없어도 함수 호출이 가능합니다.